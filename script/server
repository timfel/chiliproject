#!/usr/bin/env ruby
require File.expand_path('../../config/boot',  __FILE__)

if RUBY_ENGINE == "maglev"
  $KCODE = "us" # If this isn't defined, it'll end up in the
                # #new_constants_during when loading stuff with
                # ActiveSupport::Dependencies

  ObjectSpace.class_eval do
    def self.each_object(*args)
      # Unimplemented in Maglev
    end
  end

  require 'active_support'
  module ActiveSupport::Dependencies
    alias __qualified_const_defined? qualified_const_defined?

    def qualified_const_defined?(path)
      begin
        __qualified_const_defined?(path)
      rescue NameError => e
        puts "On MagLev, path is sometimes not a constant, but e.g. a global ($KCODE)"
        p e
        return false
      end
    end
  end

  module ActiveSupport
    module Memoizable
      module InstanceMethods
        def memoize_all
          # No-op, it'll be memoized on-demand.
          # Bug: Behavior>>_nonBridgeMethod does return sth that still is a bridge method.
          # Happens during #prime_cache for the ActiveView::Template
        end
      end
    end
  end

  # nkf is require'd by Rails 2, its implemented in C on Rbx, so we just ignore it for now
  $LOADED_FEATURES << 'nkf.rb' << 'mutex_m.rb'

  # Mutex_m is required. Taken straight from Rubinius
  require 'thread'
  module Mutex_m
    def Mutex_m.define_aliases(cl)
      cl.module_eval %q{
        alias locked? mu_locked?
        alias lock mu_lock
        alias unlock mu_unlock
        alias try_lock mu_try_lock
        alias synchronize mu_synchronize
      }
    end

    def Mutex_m.append_features(cl)
      super
      define_aliases(cl) unless cl.instance_of?(Module)
    end

    def Mutex_m.extend_object(obj)
      super
      obj.mu_extended
    end

    def mu_extended
      unless (defined? locked? and
              defined? lock and
              defined? unlock and
              defined? try_lock and
              defined? synchronize)
        Mutex_m.define_aliases(class << self; self; end)
      end
      mu_initialize
    end

    # locking
    def mu_synchronize
      @mu_mutex.synchronize { yield }
    end

    def mu_locked?
      @mu_mutex.locked?
    end

    def mu_try_lock
      @mu_mutex.try_lock
    end

    def mu_lock
      @mu_mutex.lock
      self
    end

    def mu_unlock
      @mu_mutex.unlock
      self
    end

    private

    def mu_initialize
      @mu_mutex = ::Mutex.new
    end

    def initialize(*args)
      mu_initialize
      super
    end
  end
end

require 'commands/server'
